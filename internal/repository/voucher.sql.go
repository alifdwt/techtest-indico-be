// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: voucher.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countVouchers = `-- name: CountVouchers :one
SELECT COUNT(*) FROM vouchers
WHERE ($1::text IS NULL OR voucher_code ILIKE '%' || $1 || '%')
`

func (q *Queries) CountVouchers(ctx context.Context, search pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countVouchers, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVoucher = `-- name: CreateVoucher :one
INSERT INTO vouchers (
    voucher_code,
    discount_percent,
    expiry_date
) VALUES (
    $1, $2, $3
) RETURNING id, voucher_code, discount_percent, expiry_date, created_at, updated_at
`

type CreateVoucherParams struct {
	VoucherCode     string             `json:"voucher_code"`
	DiscountPercent int32              `json:"discount_percent"`
	ExpiryDate      pgtype.Timestamptz `json:"expiry_date"`
}

func (q *Queries) CreateVoucher(ctx context.Context, arg CreateVoucherParams) (Voucher, error) {
	row := q.db.QueryRow(ctx, createVoucher, arg.VoucherCode, arg.DiscountPercent, arg.ExpiryDate)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.VoucherCode,
		&i.DiscountPercent,
		&i.ExpiryDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVoucher = `-- name: DeleteVoucher :exec
DELETE FROM vouchers WHERE id = $1
`

func (q *Queries) DeleteVoucher(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteVoucher, id)
	return err
}

const getAllVouchersForExport = `-- name: GetAllVouchersForExport :many
SELECT id, voucher_code, discount_percent, expiry_date, created_at, updated_at FROM vouchers ORDER BY created_at DESC
`

func (q *Queries) GetAllVouchersForExport(ctx context.Context) ([]Voucher, error) {
	rows, err := q.db.Query(ctx, getAllVouchersForExport)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Voucher{}
	for rows.Next() {
		var i Voucher
		if err := rows.Scan(
			&i.ID,
			&i.VoucherCode,
			&i.DiscountPercent,
			&i.ExpiryDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoucherByCode = `-- name: GetVoucherByCode :one
SELECT id, voucher_code, discount_percent, expiry_date, created_at, updated_at FROM vouchers WHERE voucher_code = $1 LIMIT 1
`

func (q *Queries) GetVoucherByCode(ctx context.Context, voucherCode string) (Voucher, error) {
	row := q.db.QueryRow(ctx, getVoucherByCode, voucherCode)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.VoucherCode,
		&i.DiscountPercent,
		&i.ExpiryDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVoucherByID = `-- name: GetVoucherByID :one
SELECT id, voucher_code, discount_percent, expiry_date, created_at, updated_at FROM vouchers WHERE id = $1 LIMIT 1
`

func (q *Queries) GetVoucherByID(ctx context.Context, id pgtype.UUID) (Voucher, error) {
	row := q.db.QueryRow(ctx, getVoucherByID, id)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.VoucherCode,
		&i.DiscountPercent,
		&i.ExpiryDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listVouchers = `-- name: ListVouchers :many
SELECT id, voucher_code, discount_percent, expiry_date, created_at, updated_at FROM vouchers
WHERE ($3::text IS NULL OR voucher_code ILIKE '%' || $3 || '%')
ORDER BY
  CASE 
    WHEN $4::text = 'asc' AND $5::text = 'expiry_date' THEN expiry_date
  END ASC, 
  CASE 
    WHEN $4::text = 'asc' AND $5::text = 'discount_percent' THEN discount_percent
  END ASC,

  CASE 
    WHEN $4::text = 'desc' AND $5::text = 'expiry_date' THEN expiry_date
  END DESC,
  CASE 
    WHEN $4::text = 'desc' AND $5::text = 'discount_percent' THEN discount_percent
  END DESC,
  
  created_at DESC

LIMIT $1 OFFSET $2
`

type ListVouchersParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	Search    pgtype.Text `json:"search"`
	SortOrder pgtype.Text `json:"sort_order"`
	SortBy    pgtype.Text `json:"sort_by"`
}

func (q *Queries) ListVouchers(ctx context.Context, arg ListVouchersParams) ([]Voucher, error) {
	rows, err := q.db.Query(ctx, listVouchers,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.SortOrder,
		arg.SortBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Voucher{}
	for rows.Next() {
		var i Voucher
		if err := rows.Scan(
			&i.ID,
			&i.VoucherCode,
			&i.DiscountPercent,
			&i.ExpiryDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVoucher = `-- name: UpdateVoucher :one
UPDATE vouchers SET
    voucher_code = $2,
    discount_percent = $3,
    expiry_date = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, voucher_code, discount_percent, expiry_date, created_at, updated_at
`

type UpdateVoucherParams struct {
	ID              pgtype.UUID        `json:"id"`
	VoucherCode     string             `json:"voucher_code"`
	DiscountPercent int32              `json:"discount_percent"`
	ExpiryDate      pgtype.Timestamptz `json:"expiry_date"`
}

func (q *Queries) UpdateVoucher(ctx context.Context, arg UpdateVoucherParams) (Voucher, error) {
	row := q.db.QueryRow(ctx, updateVoucher,
		arg.ID,
		arg.VoucherCode,
		arg.DiscountPercent,
		arg.ExpiryDate,
	)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.VoucherCode,
		&i.DiscountPercent,
		&i.ExpiryDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
